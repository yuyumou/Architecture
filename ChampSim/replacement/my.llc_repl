#include "cache.h"
#include <map>

// 定义缓存配置的常量
#define NUM_CORE 1
#define LLC_SETS NUM_CORE * 2048
#define LLC_WAYS 16

// 定义所有行的3位RRIP计数器
#define maxRRPV 7
uint32_t rrpv[LLC_SETS][LLC_WAYS];

// 每组的定时器；我们只使用其中的64个
// 预算 = 64组 * 每组1个定时器 * 每个定时器10位 = 80字节
#define TIMER_SIZE 1024
uint64_t perset_mytimer[LLC_SETS];

// 采样组的签名；我们只使用其中的64个
// 预算 = 64组 * 16路 * 每行12位签名 = 1.5B
uint64_t signatures[LLC_SETS][LLC_WAYS];
bool prefetched[LLC_SETS][LLC_WAYS];

// Hawkeye预测器用于需求和预取请求
// 每个预测器有2K个条目和每个条目5位计数器
// 预算 = 2048*5/8 字节 = 1.2KB
#define MAX_SHCT 31
#define SHCT_SIZE_BITS 11
#define SHCT_SIZE (1 << SHCT_SIZE_BITS)
#include "hawkeye_predictor.h"
HAWKEYE_PC_PREDICTOR *demand_predictor;    // 需求预测器
HAWKEYE_PC_PREDICTOR *prefetch_predictor;  // 预取预测器

#define OPTGEN_VECTOR_SIZE 128
#include "optgen.h"
OPTgen perset_optgen[LLC_SETS];  // 每组占用向量；我们只使用其中的64个

#include <math.h>
#define bitmask(l) (((l) == 64) ? (unsigned long long)(-1LL) : ((1LL << (l)) - 1LL))
#define bits(x, i, l) (((x) >> (i)) & bitmask(l))
// 每个核采样64组
#define SAMPLED_SET(set) (bits(set, 0, 6) == bits(set, ((unsigned long long)log2(LLC_SETS) - 6), 6))

// 采样器，用于跟踪采样组的8倍缓存历史
// 2800个条目 * 每个条目4字节 = 11.2KB
#define SAMPLED_CACHE_SIZE 2800
#define SAMPLER_WAYS 8
#define SAMPLER_SETS SAMPLED_CACHE_SIZE / SAMPLER_WAYS
vector<map<uint64_t, ADDR_INFO>> addr_history;  // 采样器

// sacusa：附加数据的结构
uint64_t num_of_evictions;
uint64_t num_of_cache_friendly_evictions;

// 初始化替换状态
void CACHE::llc_initialize_replacement()
{
    for (int i = 0; i < LLC_SETS; i++)
    {
        for (int j = 0; j < LLC_WAYS; j++)
        {
            rrpv[i][j] = maxRRPV;
            signatures[i][j] = 0;
            prefetched[i][j] = false;
        }
        perset_mytimer[i] = 0;
        perset_optgen[i].init(LLC_WAYS - 2);
    }

    addr_history.resize(SAMPLER_SETS);
    for (int i = 0; i < SAMPLER_SETS; i++)
        addr_history[i].clear();

    demand_predictor = new HAWKEYE_PC_PREDICTOR();
    prefetch_predictor = new HAWKEYE_PC_PREDICTOR();

    cout << "初始化Hawkeye状态" << endl;

    // sacusa
    num_of_evictions = 0;
    num_of_cache_friendly_evictions = 0;
}

// 查找替换受害者
// 返回值应为0 ~ 15或16（绕过）
uint32_t CACHE::llc_find_victim(uint32_t cpu, uint64_t instr_id, uint32_t set, const BLOCK *current_set, uint64_t PC, uint64_t paddr, uint32_t type)
{
    // sacusa：用于计算缓存友好替换百分比的数据
    num_of_evictions++;

    // 查找最大RRPV行
    for (uint32_t i = 0; i < LLC_WAYS; i++)
        if (rrpv[set][i] == maxRRPV)
            return i;

    // 如果找不到缓存不友好的行，则驱逐最老的缓存友好行
    num_of_cache_friendly_evictions++;
    uint32_t max_rrip = 0;
    int32_t lru_victim = -1;
    for (uint32_t i = 0; i < LLC_WAYS; i++)
    {
        if (rrpv[set][i] >= max_rrip)
        {
            max_rrip = rrpv[set][i];
            lru_victim = i;
        }
    }

    assert(lru_victim != -1);
    // 在LRU驱逐上负向训练预测器
    if (SAMPLED_SET(set))
    {
        if (prefetched[set][lru_victim])
            prefetch_predictor->decrement(signatures[set][lru_victim]);
        else
            demand_predictor->decrement(signatures[set][lru_victim]);
    }
    return lru_victim;

    // 我们不应该到达这里
    assert(0);
    return 0;
}

void replace_addr_history_element(unsigned int sampler_set)
{
    uint64_t lru_addr = 0;

    for (map<uint64_t, ADDR_INFO>::iterator it = addr_history[sampler_set].begin(); it != addr_history[sampler_set].end(); it++)
    {
        // uint64_t timer = (it->second).last_quanta;

        if ((it->second).lru == (SAMPLER_WAYS - 1))
        {
            // lru_time =  (it->second).last_quanta;
            lru_addr = it->first;
            break;
        }
    }

    addr_history[sampler_set].erase(lru_addr);
}

void update_addr_history_lru(unsigned int sampler_set, unsigned int curr_lru)
{
    for (map<uint64_t, ADDR_INFO>::iterator it = addr_history[sampler_set].begin(); it != addr_history[sampler_set].end(); it++)
    {
        if ((it->second).lru < curr_lru)
        {
            (it->second).lru++;
            assert((it->second).lru < SAMPLER_WAYS);
        }
    }
}

// 每次缓存命中和缓存填充时调用
void CACHE::llc_update_replacement_state(uint32_t cpu, uint32_t set, uint32_t way, uint64_t paddr, uint64_t PC, uint64_t victim_addr, uint32_t type, uint8_t hit)
{
    paddr = (paddr >> 6) << 6;

    if (type == PREFETCH)
    {
        if (!hit)
            prefetched[set][way] = true;
    }
    else{
        prefetched[set][way] = false;
    }

    // 忽略写回
    if (type == WRITEBACK)
        return;

    // 如果我们正在采样，OPTgen将只看到来自采样组的访问
    if (SAMPLED_SET(set))
    {
        // 当前时间步
        uint64_t curr_quanta = perset_mytimer[set] % OPTGEN_VECTOR_SIZE;

        uint32_t sampler_set = (paddr >> 6) % SAMPLER_SETS;
        uint64_t sampler_tag = CRC(paddr >> 12) % 256;
        assert(sampler_set < SAMPLER_SETS);

        // 该行以前已经被使用过。由于使用间隔的右端总是一个需求，因此忽略预取
        if ((addr_history[sampler_set].find(sampler_tag) != addr_history[sampler_set].end()) && (type != PREFETCH))
        {
            unsigned int curr_timer = perset_mytimer[set];
            if (curr_timer < addr_history[sampler_set][sampler_tag].last_quanta)
                curr_timer = curr_timer + TIMER_SIZE;
            bool wrap = ((curr_timer - addr_history[sampler_set][sampler_tag].last_quanta) > OPTGEN_VECTOR_SIZE);
            uint64_t last_quanta = addr_history[sampler_set][sampler_tag].last_quanta % OPTGEN_VECTOR_SIZE;
            // 对于预取命中，我们使用最后的预取触发PC进行训练
            if (!wrap && perset_optgen[set].should_cache(curr_quanta, last_quanta))
            {
                if (addr_history[sampler_set][sampler_tag].prefetched)
                    prefetch_predictor->increment(addr_history[sampler_set][sampler_tag].PC);
                else
                    demand_predictor->increment(addr_history[sampler_set][sampler_tag].PC);
            }
            else
            {
                // 因为OPT不会缓存这一行，所以对预测器进行负面训练
                if (addr_history[sampler_set][sampler_tag].prefetched)
                    prefetch_predictor->decrement(addr_history[sampler_set][sampler_tag].PC);
                else
                    demand_predictor->decrement(addr_history[sampler_set][sampler_tag].PC);
            }
            // 对OPTgen的一些维护操作
            perset_optgen[set].add_access(curr_quanta);
            update_addr_history_lru(sampler_set, addr_history[sampler_set][sampler_tag].lru);

            // 由于这是一个需求访问，将预取位标记为false
            addr_history[sampler_set][sampler_tag].prefetched = false;
        }
        // 这是我们第一次见到这一行（可能是需求或预取）
        else if (addr_history[sampler_set].find(sampler_tag) == addr_history[sampler_set].end())
        {
            // 如果正在采样，从采样缓存中找到受害者
            if (addr_history[sampler_set].size() == SAMPLER_WAYS)
                replace_addr_history_element(sampler_set);

            assert(addr_history[sampler_set].size() < SAMPLER_WAYS);
            // 在采样器中初始化新的条目
            addr_history[sampler_set][sampler_tag].init(curr_quanta);
            // 如果是预取，标记prefetched位
            if (type == PREFETCH)
            {
                addr_history[sampler_set][sampler_tag].mark_prefetch();
                perset_optgen[set].add_prefetch(curr_quanta);
            }
            else
                perset_optgen[set].add_access(curr_quanta);
            update_addr_history_lru(sampler_set, SAMPLER_WAYS - 1);
        }
        else // 这一行是一个预取
        {
            assert(addr_history[sampler_set].find(sampler_tag) != addr_history[sampler_set].end());
            // 如果命中并且是预取
            uint64_t last_quanta = addr_history[sampler_set][sampler_tag].last_quanta % OPTGEN_VECTOR_SIZE;
            if (perset_mytimer[set] - addr_history[sampler_set][sampler_tag].last_quanta < 5 * NUM_CORE)
            {
                // 如果应该缓存，更新预测器
                if (perset_optgen[set].should_cache(curr_quanta, last_quanta))
                {
                    if (addr_history[sampler_set][sampler_tag].prefetched)
                        prefetch_predictor->increment(addr_history[sampler_set][sampler_tag].PC);
                    else
                        demand_predictor->increment(addr_history[sampler_set][sampler_tag].PC);
                }
            }

            // 标记prefetched位
            addr_history[sampler_set][sampler_tag].mark_prefetch();
            // 对OPTgen的一些维护操作
            perset_optgen[set].add_prefetch(curr_quanta);
            update_addr_history_lru(sampler_set, addr_history[sampler_set][sampler_tag].lru);
        }

        // 获取Hawkeye对该行的预测
        bool new_prediction = demand_predictor->get_prediction(PC);
        if (type == PREFETCH)
            new_prediction = prefetch_predictor->get_prediction(PC);
        // 使用时间戳、PC和我们的预测更新采样器
        addr_history[sampler_set][sampler_tag].update(perset_mytimer[set], PC, new_prediction);
        addr_history[sampler_set][sampler_tag].lru = 0;
        // 增加组定时器
        perset_mytimer[set] = (perset_mytimer[set] + 1) % TIMER_SIZE;
    }

    bool new_prediction = demand_predictor->get_prediction(PC);
    if (type == PREFETCH)
        new_prediction = prefetch_predictor->get_prediction(PC);

    signatures[set][way] = PC;

    // 设置RRIP值并将缓存友好的行年龄增加
    if (!new_prediction)
        rrpv[set][way] = maxRRPV;
    else
    {
        rrpv[set][way] = 0;
        if (!hit)
        {
            bool saturated = false;
            for (uint32_t i = 0; i < LLC_WAYS; i++)
                if (rrpv[set][i] == maxRRPV - 1)
                    saturated = true;

            // 将所有缓存友好的行年龄增加
            for (uint32_t i = 0; i < LLC_WAYS; i++)
            {
                if (!saturated && rrpv[set][i] < maxRRPV - 1)
                    rrpv[set][i]++;
            }
        }
        rrpv[set][way] = 0;
    }
}

// 用于在模拟结束时打印出你自己的统计信息
void CACHE::llc_replacement_final_stats()
{
    unsigned int hits = 0;
    unsigned int demand_accesses = 0;
    unsigned int prefetch_accesses = 0;
    for (unsigned int i = 0; i < LLC_SETS; i++)
    {
        demand_accesses += perset_optgen[i].demand_access;
        prefetch_accesses += perset_optgen[i].prefetch_access;
        hits += perset_optgen[i].get_num_opt_hits();
    }

    std::cout << "OPTgen 需求访问数: " << demand_accesses << std::endl;
    std::cout << "OPTgen 预取访问数: " << prefetch_accesses << std::endl;
    std::cout << "OPTgen 命中数: " << hits << std::endl;
    std::cout << "OPTgen 命中率: " << 100 * (double)hits / ((double)demand_accesses + (double)prefetch_accesses) << std::endl;
    std::cout << "驱逐次数: " << num_of_evictions << std::endl;
    std::cout << "缓存友好的驱逐次数: " << num_of_cache_friendly_evictions << std::endl;

    cout << endl
         << endl;
    return;
}
